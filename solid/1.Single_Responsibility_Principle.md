Awesome! Setup done ‚Äî welcome to Day 1 of becoming an LLD + Design Patterns beast! üî•

### Knowledge Tracker (current status)
| Principle                  | Status       | Depth Level | Last Practiced | Needs Revision? |
|----------------------------|--------------|-------------|----------------|-----------------|
| Single Responsibility     | Not started  | ‚Äì           | ‚Äì              | ‚Äì               |
| Open/Closed                | Not started  | ‚Äì           | ‚Äì              | ‚Äì               |
| Liskov Substitution        | Not started  | ‚Äì           | ‚Äì              | ‚Äì               |
| Interface Segregation      | Not started  | ‚Äì           | ‚Äì              | ‚Äì               |
| Dependency Inversion       | Not started  | ‚Äì           | ‚Äì              | ‚Äì               |

Let‚Äôs kick off with the mother of all principles.

## 1 Single Responsibility Principle (SRP)

Official definition (Uncle Bob):  
‚ÄúA class should have only one reason to change.‚Äù  
‚Üí Meaning: There should be only one job or responsibility that can make this class change.

Plain English translation:  
Every class/file should do exactly ONE thing well. If you can think of two different reasons why someone would modify this class in the future, it‚Äôs already violating SRP.

### Real-World Example Everyone Understands
Think of a restaurant:
- Chef ‚Üí cooks food
- Waiter ‚Üí takes orders & serves
- Accountant ‚Üí handles bills

If one person does all three jobs ‚Üí chaos when menu changes, prices change, or cooking process changes.

### Classic Violation (you will see this in almost every beginner code)
```java
public class User {
    private String name;
    private String email;

    // Responsibility 1: Store user data
    public void setName(String name) { this.name = name; }
    public void setEmail(String email) { this.email = email; }

    // Responsibility 2: Validate email
    public boolean isValidEmail() {
        return email.contains("@") && email.contains(".");
    }

    // Responsibility 3: Save to database
    public void saveToDatabase() {
        // JDBC code or JPA code here
        System.out.println("Saving " + name + " to DB...");
    }

    // Responsibility 4: Send welcome email
    public void sendWelcomeEmail() {
        // SMTP code
        System.out.println("Welcome email sent to " + email);
    }
}
```

This single class has at least FOUR reasons to change:
1. Business rules about user fields change
2. Email validation rules change (e.g., new TLDs)
3. Database schema or ORM changes
4. Email content or provider changes

### Correct SRP Version
```java
// 1. Only holds data + basic getters/setters
public class User {
    private String name;
    private String email;
    // getters & setters only
}

// 2. Only validates
public class UserValidator {
    public boolean isValid(User user) {
        return user.getEmail().contains("@") && user.getEmail().contains(".");
    }
}

// 3. Only persists
public class UserRepository {
    public void save(User user) {
        // database logic only
    }
}

// 4. Only sends emails
public class EmailService {
    public void sendWelcomeEmail(User user) {
        // email logic only
    }
}
```

### Your First Mini-Challenge (Do this now!)

I‚Äôm giving you deliberately bad code that violates SRP heavily (exactly the kind Prateek shows in the course).

File: `Invoice.java`
```java
public class Invoice {
    private String invoiceId;
    private String customerName;
    private double amount;
    private double taxRate = 0.18;

    public Invoice(String invoiceId, String customerName, double amount) {
        this.invoiceId = invoiceId;
        this.customerName = customerName;
        this.amount = amount;
    }

    // Calculates total with tax
    public double calculateTotal() {
        return amount + (amount * taxRate);
    }

    // Prints invoice directly to console
    public void printInvoice() {
        System.out.println("======= INVOICE =======");
        System.out.println("ID: " + invoiceId);
        System.out.println("Customer: " + customerName);
        System.out.println("Amount: " + amount);
        System.out.println("Tax: " + (amount * taxRate));
        System.out.println("Total: " + calculateTotal());
        System.out.println("=======================");
    }

    // Saves to file (hardcoded path!)
    public void saveToFile() {
        try {
            FileWriter writer = new FileWriter("invoices/" + invoiceId + ".txt");
            writer.write(toString());
            writer.close();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    @Override
    public String toString() {
        return "Invoice{" +
                "invoiceId='" + invoiceId + '\'' +
                ", customerName='" + customerName + '\'' +
                ", amount=" + amount +
                '}';
    }
}
```

Your task (try it yourself first!):
1. Identify ALL responsibilities this class currently has (hint: there are at least 4)
2. Refactor it into multiple classes following SRP strictly
3. Keep the public API simple (someone should still be able to do `new Invoice(...).generate()` or similar)

Spend 20‚Äì30 minutes on this. When you‚Äôre done (or stuck), paste your refactored version here and I‚Äôll give you detailed feedback + modern Java improvements.

Let the refactoring begin! üí™
